\chapter{Теоретическое введение}

\section{Гедонические игры}
Введем определение гедонической игры, которое будет использоваться на протяжении всего исследования.\\

Пусть есть множество агентов $\{1,...,N\}$, $\sigma$ - некоторое разбиение агентов на сообщества, $\sigma=\{S_1,...,S_n,\textbf{ }S_i\cap S_j=\emptyset,\textbf{ }\cup_i S_i=\{1,...,N\}\}$. Агентов будем также называть игроками. Для каждого агента задана функция полезности $u_i(\sigma)$ (или, иначе, функция прибыли), зависящая от текущего разбиения. Пусть агенты могут свободно перемещаться между кластерами. В данной работе \textit{стратегией} игрока будем называть сообщество, которое данный игрок выбирает. Задача состоит в том, чтобы отыскать \textit{оптимальные стратегии} для каждого игрока: то есть, при выборе данной стратегии игрок имеет максимальную прибыль при фиксированных оптимальных стратегиях всех остальных игроков. В данной работе мы будем рассматривать \textit{некооперативные} игры. Это означает, что два или более игрока не могут действовать согласованно, то есть каждый игрок выбирает стратегию, принимая во внимание только собственную прибыль (\textit{"selfish"} players). Результирующее разбиение, в котором никакой игрок не хочет изменить стратегию, и будет искомым разбиением множества агентов на сообщества.\\

Будем называть игру \textit{гедонической}, если функция полезности $u_i$ каждого игрока зависит только от того, какие еще игроки входят в сообщество, которому принадлежит рассматриваемый игрок. При этом разбиение оставшихся вершин на сообщества никак не влияет на прибыль рассматриваемого игрока. С помощью некооперативных гедонических игр можно моделировать множество ситуаций, в которых агенты объединяются в сообщества, исходя из личных интересов. Впервые гедонические игры были введены и проанализированы в этой работе \cite{firsthg}. Большинство работ по гедоническим играм посвящено изучению \textit{равновесия Нэша} (набора оптимальных стратегий игроков, при которых никакой игрок не хочет изменить свою стратегию при фиксированных оптимальных стратегиях других игроков), а также нахождению оптимальных стратегий игроков, доказательству существования или отсутствия равновесия Нэша в различных игровых моделях \cite{core1}, \cite{core2}, \cite{core3}.\\

Чтобы лучше понять, как могут быть устроены гедонические алгоритмы поиска сообществ, рассмотрим примеры конкретных алгоритмов и решаемых ими задач. Как и в метрических алгоритмах кластеризации, количество кластеров в некоторых теоретико-игровых алгоритмах известно заранее, а в других - нет. Приведем несколько существующих алгоритмов.\\

Кластеризацию первого типа в литературе часто называют "fixed clustering". Примедем пример такого алгоритма, кластеризующего полный взвешенный неориентированный граф. Назовем условно веса ребер графа "расстояниями". Пусть число кластеров известно заранее и равно $k$. В таком случае удобно формировать кластеры вокруг так называемых "центроидов" - представителей каждого из $k$ кластеров. Введем "цену" кластера - сумму расстояний от всех агентов в данном кластере до его центроида. Тогда введем цену $c_v(C)$, которую платит агент $v$ за нахождение в кластере $C$, как цену кластера $C$, разделенную поровну между его агентами. Теперь прибыль игрока можно считать равной $-c_v$. Набор стратегий игрока - $k$ чисел, обозначающих номера кластеров, которые можно выбрать. На каждом шаге игроку $v$ нужно выбрать такой кластер $C$, что величина $c_v(C\cup v)$ минимальна, где $c_v$ - "цена", которую платит $v$ при заданном разбиении на сообщества. Оказывается, что агенту нужно минимизировать собственное расстояние до центроида \cite{clusteringhg}. Примером применения такого алгоритма является организация передачи данных между устройствами, минимизирующая энергетические затраты: устройства объединяются в кластеры согласно приведенному алгоритму, и передача данных осуществляется только между агентом и центроидом одного кластера и между центроидами.\\

Кластеризация второго типа имеет еще более широкое применение, так как зачастую количество кластеров заранее неизвестно. Пусть известны только "отношения" между агентами - веса ребер графа. Предположим, что между агентами теперь задана метрика: $d:(, v)\rightarrow [0,1]$. Пусть $d(u, v)$ обозначает "меру различия" объектов $u$ и $v$: если $d(u, v)$ близко к нулю, то объекты похожи, а если, напротив, $d(u, v)$ близко к единице, то объекты очень разные. Пусть также каждый агент $v$ имеет вес $w_v$, обозначающий "меру влияния" на остальных. Пусть агенты хотят быть в одном кластере с близкими им объектами с большим весом, но отделиться непохожих на них агентов с маленьким весом. С помощью функции полезности агента можно это учесть \cite{clusteringhg}. Так можно решать любую задачу, в которой, например, агенты хотят объединиться "по интересам", отдалившись от тех, кто на них не похож.\\

Второй пример важен для нас в данной работе, так как мы будем рассматривать именно этот тип кластеризации, когда количество кластеров заранее неизвестно. Кроме того, мы будем использовать похожую функцию полезности, но функция веса ребер графа $d(u, v)$ уже не будет метрикой, и даже не будет определена для всех пар вершин. Соответственно, $d(u, v)$ уже нельзя считать расстоянием. Веса вершин в нашей работе также будут использоваться, но будет рассмотрено большое их количество, и зависеть они будут от топологии графа, чего в рассмотренной выше постановке быть не может. Про веса вершин будет подробно рассказано в следующей части теоретического введения. 

\section{Центральности}

Понимание роли каждого элемента системы является важным шагом в изучении поведения этой системы. Мы будем рассматривать кластеризацию ориентированных графов (или, иначе, \textit{сети}) с различной топологией, а значит, разные вершины в такой сети будут иметь разное положение относительно всех остальных. Если рассматривать ребро графа как некоторую характеристику "влияния" одной вершины на другую, то такие характеристики, как количество out-соседей, веса out-ребер, а также то, каким "влиянием" обладают сами out-соседи вершины, может характеризовать "важность" вершины в сети. Такая мера "важности" вершины графа называется \textit{мерой центральности}. Мер центральности можно ввести очень много. Рассмотрим здесь те, которые будем использовать для определения важности вершин в данной работе.

\subsection{Betweenness \cite{betweenness}}
Эта мера широко используется в социальных сетях. Она основана на предположении о том, что, если человек в некоторой социальной группе имеет некоторое "центральное" положение, соединяя много пар других людей, то он "важен" для этой группы. Этот человек может в какой-то мере контролировать общение людей, связанных между собой через него кратчайшин путем. В терминах сети, если вершина лежит на большом количестве кратчайших путей между другими вершинами, то мера центральности этой вершины должна быть высокой. Рассмотрим вершины графа $i$ и $j$. Пусть число всех кратчайших путей (называемых также \textit{геодезическими}) из $i$ в $j$ равно $g_{ij}$. Тогда вероятность, что $i$ выберет один из этих путей $p$ для передачи информации $j$, есть $g_{ij}^{-1}$. Тогда для каждой вершины $k$ графа обозначим как $g_{ij}(k)$ число кратчайших путей из $i$ в $j$, содержащих $k$. Тогда мера центральности $k$ вводится следующим образом:
	\begin{equation}
	b_{ij}(k) = \frac{g_{ij}(k)}{g_{ij}},
	\end{equation}
	\begin{equation}
	C_B(k) = \sum_{i<j}b_{ij}(k),
	\end{equation}
	где $b_{ij}(k)$ - вероятость того, что на выбранном пути передачи информации из $i$ в $j$ содержится $k$. 
	
\subsection{Degree}
В некоторых сетях удобно ввести меру центральности так, чтобы она зависела от степени вершины. Например, рассмотрим распространение инноваций в социальных сетях. Чем больше степень вершины, тем больше вершин могут "заразиться" от данной (принять инновацию). В нашей задаче граф ориентированный, поэтому мера центральности вершины будет пропорциональна числу исходящих ребер (out-степени вершины). Обозначим через $d_{max}$ максимальную out-степень вершины в графе. Тогда меру центральности вершины $i$ будем считать так:
	\begin{equation}
	C_d(i) = \frac{\sum_{j\neq i} \delta_{ij}}{d_{max}},
	\end{equation}
	\begin{equation}
	d_{max} = \max_i\{\sum_{j\neq i}\delta_{ij}\},
	\end{equation}
	где $\delta_{ij}=0$, если ребра $i\rightarrow j$ нет, $\delta_ij=1$, если ребро $i \rightarrow j$ есть.\\
	
	Также рассмотрим \textit{weighted} (взвешенную) degree-центральность, в которой важность вершины будет зависеть не только от числа исходящих ребер, но и от их веса (например, в уже рассмотренной социальной сети наличие связи не говорит о том, что информация точно будет передана; вместо этого, можно задать вес ребра как некоторую величину, оценивающую вероятность передачи информации по ребру). Теперь нам потребуется максимальная по всем вершинам сумма весов исходящих ребер в графе: $w_{max}$. Мера центральности вершины $i$:
	\begin{equation}
	C_{wd}(i) = \frac{\sum_{j\neq i} \delta_{ij}\cdot w_{ij}}{w_{max}},
	\end{equation}
	\begin{equation}
	w_{max} = \max_i\{\sum_{j\neq i}\delta_{ij}\cdot w_{ij}\},
	\end{equation}
	где $w_{ij}$ - вес ребра $i \rightarrow j$.
	
	\subsection{Closeness}
	Эта мера центральности, как нетрудно понять из названия, характеризует "близость" вершины ко всем остальным вершинам графа. Пусть $d_{ij}$ - число ребер в кратчайшем пути от вершины $i$ до вершины $j$. Тогда рассмотрим меру:
	\begin{equation}
	D_c(i)=\sum_{j\neq i} d_{ij}.
	\end{equation}
	Указанная величина имеет противоположный смысл: чем меньше сумма кратчайших расстояний от данной вершины до всех остальных, тем более она "центральна". Значит, меру центральности вершины $i$ можно ввести как величину, обратную $D_c(i)$:
	\begin{equation}
	C_c(i) = \frac{1}{\sum_{j\neq i} d_{ij}}.
	\end{equation}
	В уже рассмотренной задаче распространения инноваций closeness-центральность может характеризовать скорость распространения инновации по сети от заданного узла.
	
	\subsection{PageRank \cite{pagerankcent}}
	Центральность вершины в ориентированном графе можно измерить с помощью известного алгоритма ранжирования страниц, соответствующих некоторому поисковому запросу. Согласно алгоритму PageRank, вес страницы А тем больше, чем больше вес страниц В, на нее ссылающихся. Также чем больше страниц В ссылаются на данную страницу А, тем больше вес страницы А. Формулу задают так:
	\begin{equation}
	PR(A)=(1-d)+d\cdot (\frac{PR(T_1)}{C(T_1)}+\dots+\frac{PR(T_n)}{C(T_n)}),
	\end{equation}
	где $PR(A)$ - вычисляемый вес страницы А, $d$ - коэффициент "затухания" (необходим для того, чтобы циклы, появляющиеся, например, если А ссылается на В и В ссылается на А, не "стягивали" на себя всю центральность), $PR(T_i)$ - вес страницы $T_i$, ссылающейся на А, $C(T_i)$ - число ссылок на странице $T_i$, $n$ - число страниц $T_i$, ссылающихся на А \cite{pagerank}.
	
	\subsection{Статические веса}
	Для теоретического исследования алгоритма понадобятся статические веса вершин, которые в работе будут иногда обозначаться \textit{static}. Это означает, что веса всех вершин одинаковы и равны $\frac{1}{2}$.
	
	\subsection{Случайные веса}
	Важности вершин в реальных задачах не всегда зависят от топологии графа: они могут быть получены, например, на основании экспертного мнения. Однако, кластериация такого графа все еще будет зависеть от топологии. Для изучения такого случая можно присвоить вершинам случайные (\textit{random}) веса, лежащие на отрезке $[0,1]$.

\section{Модулярность}
